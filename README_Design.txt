Design document:

I decided to write this project in Java, because Java is the language I am most familiar with.  I understand that there are other languages which might be more suitable for this task, but with only 3 days to complete the project, I decided I would rather stick to a tech stack I know as opposed to having to learn a brand new language and tech stack in a small amount of time.

I decided to write this application using ImageMagick.  After seeing it as a suggestion in the assignment specification, I looked into it a little bit and foud that it was quite easy to use.  I also found that ImageMagick has a bunch of Java libraries that could be used for implementation.  I decided t use Maven because I was originally unsure if I would use any of these libraries, and to give me flexibility in adding/removing them later on I decided starting with a Maven configuration would be useful.  I ended up not using these libraries, but I did use other Maven libraries such as Log4J and Mockito.

The reason I did not use the ImageMagick libraries was because they were too complicated for what I was doing.  In fact, the library Im4java specifically states in its documentation: 

"All the magic of im4java ist to hide the complexities. If you have just one simple call of an external tool in your program, you might be better of by hardcoding the ProcessBuilder-call yourself. If you don't need the simplicity or the advanced features of the im4java-library, your code will certainly be faster and more efficient." (http://im4java.sourceforge.net/docs/dev-guide.html)

I decided based on this that Im4java was not the correct tool to use for my application, and that I would be better off just doing the Process stuff myself manually.

Regarding the design of the main application, originally I built the application using One Big Class.  When I realized my One Big Class was getting too big, I split it in half by responsibility: the ImageCompareTool class was responsible for the application itself, while the ImageCompareController was responsible for manipulations involving the images.  As you can see, most of the IO (and especially the IO to file) is done in the ImageCompareTool class.  I added a ProcessGenerator class to handle the process generation to make the code more testable.  When I was implementing unit tests, I foud that mocking out the behaviour of creating the process was very difficult, and so I subdivided that into its own class.  The ProcessGenerator class is responsible for everything to do with generating and running ImageMagick directly.  There are no unit tests for this class becaue testing this functionality in unit tests is very difficult (as per above).

In working with ImageMagick, I realized that the compare method could not handle images of different sizes.  This was the main fork in the road in the application: The choice I had to make was whether to decide that two images of different sies were "obviously" dissimilar and simply return a value based on that, or to choose a diffferent path.  The path I chose was to say that I wanted to consider the same image, resized, as a similar image.  As a result, I added a resize procedure to the tool before doing the comparison.  In this way, if the second image was simply the first image resized, the similarity metric would show that the two images are very similar (if not the exact same).  However, the downside of this approach is that it creates a lossy comparison of the images; when comparing two images, say, of NASA-level quality, the comparison may be slightly inaccurate.  I believe this tradeoff is acceptable.

Regarding the similarity metric, the metric I chose to use was a normalized percentage of pixels which are different between the two images.  Two identical images will have a similarity metric of zero, as no pixels are different.  Conversely, two images which are different in every possible way will have a similarity metric of 1.  Other comparisons will have similarity metrics between zero and one, increasing as their dissimilarity increases.  Therefore, to return to the above topic, if one image is simply a resized version of the other, then the similarity metric should be very low (although nonzero) to give the user an idea that maybe these two images are worth considering more heavily to determine if they're the same or not.

Regarding input parameters, the assignment specification says to simply read the parameters in order.  However, personally speaking, when I use Unix applications, I don't always remember the order in which the parameters have to be.  Therefore, using applications which use flags for their arguments is much easier for me.  As a quality-of-life improvement, I decided to use flags rather than argument order to determine meaning of arguments.  I also decided to make the output file location configurable by the user in case they wanted to store multiple instances of their output, for a historical reference, as an additional quality of life improvement.  I wrote the code to handle this myself, although I am aware there are libraries to do it.  However, I just found it easier to write the code myself; the libraries I found looked very complicated, and didn't look like they would significantly improve the code in a meaningful way.  Ideally I would write a shellscript to handle the arguments and run the JAR, but since the application has to be portable I would have to write a script for Windows and a separate one for Mac.  Since I am unfamiliar with Windows scripting I decided to avoid this avenue, although it is a possible quality of life improvement that I would take if I had easy access to a Windows environment to verify and test my script on.
